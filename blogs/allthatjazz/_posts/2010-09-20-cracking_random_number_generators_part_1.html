---
title: "Cracking Random Number Generators - Part 1"
date: 2010-09-20T21:41:01.537+10:00
tags: prng
---
<p>
This is the first in a series of posts I'm going to give on how to crack common random number generators.
</p>

<p>
Random number generators are a key part of web security.  They are used all over the place, from session tokens to tokens to sent to an email address to verify its owner made a particular request, to CAPTCHA tokens and so on.  In all these applications, if the token can be predicted, then the security mechanism can be broken, and a malicious user will be able to identify themselves as someone who they are not.
</p>

<p>
There are obvious concerns with publishing instructions explaining how to exploit security vulnerabilities.  However, I have some good reasons for doing so:
</p>

<ol>
<li>
There is nothing new about the vulnerabilities associated with random number generation, nothing that I'm publishing here is new to hackers either.
</li>
<li>
Hacking random number generators is actually very easy to do, and hackers know this.
</li>
<li>
Many developers that I have come across are of the belief that hacking random number generators is a hard to exploit avenue of attack.  Even when they know that there are dangers in random number generation, their understanding is often incomplete, leading them to make serious mistakes.
</li>
<li>
None of the algorithms I supply here can be used as is, they require an attacker to know exactly what algorithm is being used on a system, how to extract numbers out of it, and having then cracked the number generator, how to exploit it.  Knowing all this I believe is harder than working out for yourself how to crack the random number generators themselves, so if they couldn't work out what I am saying for themselves, they likely won't be able to use it to hack into a real system.
</li>
</ol>

<p>
Hence I believe that there is nothing a hacker will learn from this series that they can't work out for themselves.  Meanwhile, many developers live in ignorance, and would never bother to see if their understanding of random number generators is flawed.  My hope therefore is to give developers an understanding of just how dangerous their ignorance can be.
</p>

<p>
What I won't talk about in this series is anything about the maths of random number generators, beyond explaining how the algorithms are implmented.  Why a particular algorithm makes a good PRNG is beyond the scope of this series.
</p>

<h2>Linear Congruential PRNG</h2>

<p>
The first PRNG we will focus on is the linear congruential PRNG.  Rather than talk theoretically, we'll look at a particularly common one, Java's default random number generator, <tt>java.util.Random</tt>.
</p>

<p>
The idea behind a linear congruential PRNG is that you store a single number as the internal state.  This state is usually called the seed, because the two numbers are usually one in the same thing.  In Java's case, this is not quite true, but to keep our explanation simple, we will assume that it is.  The seed has a precision, in Java's case, the precision is 48 bits.
</p>

<p>
The seed changes each time a number is generated, by applying a simple formula.  That formula is:
</p>

<pre class="prettyprint"><code class="language-java">seed = (seed * multiplier + addend) mod (2 ^ precision)
</code></pre>

<p>
The key to this being a good random number generator is the choice of <tt>multiplier</tt> and <tt>addend</tt>.  In Java's case, the multiplier is 25214903917, and the addend is 11.  As I said earlier, what makes these two numbers good is beyond the scope of this series.  The mod operation is implemented using a bitmask, 48 1's.
</p>

<p>
<tt>java.util.Random</tt> never gives out its full 48 bits of state, it gives out at most 32 on each call to <tt>nextInt()</tt>.  Other calls that return more bits, for example, <tt>nextLong()</tt>, generate multiple 32 bit numbers and combine them together.  To convert the 48 bit seed to a 32 bit int, the seed is bitshifted to the right by 16 bits.
</p>

<h2>Determining the seed from a Linear Congruential PRNG's output</h2>

<p>
It is not possible, from one int generated by <tt>java.util.Random</tt>, to determine the seed, because 16 bits were discarded by the bitshift.  However, if we obtain a second int from it, we can quite easily guess what those remaining 16 bits were, by brute forcing all possible values, and seeing if the next value from that matches the second value we obtained.  16 bits is only 65536 possible values, and calculating the next int is only a few instructions, so this can be computed in a fraction of a second.
</p>

<p>The code in Java looks like this:</p>

<pre class="prettyprint"><code class="language-java">Random random = new Random();
long v1 = random.nextInt();
long v2 = random.nextInt();
for (int i = 0; i &lt; 65536; i++) {
    long seed = v1 * 65536 + i;
    if (((seed * multiplier + addend) &amp; mask) &gt;&gt;&gt; 16) == v2) {
        System.out.println(&quot;Seed found: &quot; + seed);
        break;
    }
}
</code></pre>

<p>
As can be seen, given two integers from <tt>java.util.Random</tt>, we can predict all future generated integers.  In <a href="2010/09/21/cracking_random_number_generators_part_2.html">Part 2</a> we'll get a little more involved in the maths, and learn how to calculate the previous seeds.
</p>